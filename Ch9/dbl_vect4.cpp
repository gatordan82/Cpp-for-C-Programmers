/**********************************************************************  Filename:  dbl_ve~2.cpp  Chapter:   9      Exceptions  Compiler:  Borland C++     Version 5.01      Summer 1998  C++ for C Programmers, Edition 3     By Ira Pohl********************************************************************/#include <iostream>#include <assert>#include <stdlib>//using namespace std;const int DSIZE = 6;class dbl_vect {public:   //constructors and destructor   explicit dbl_vect(int n = 10);   dbl_vect(const dbl_vect& v);   dbl_vect(const double a[], int n);      //initialize by array   ~dbl_vect() { delete []p; }   //other member functions   int  ub()const { return (size-1); }     //upper bound   void print() const;   double&  operator[](int i) ;            //range checked   dbl_vect& operator=(const dbl_vect& v); //assignment   dbl_vect operator+(const dbl_vect& v);private:   double*  p;                             //base pointer   int  size;                              //number of elements};dbl_vect::dbl_vect(const double a[], int n) : size(n){   assert(n > 0);   p = new double[size];   assert(p != 0);   for (int i = 0; i < size; ++i)      p[i] = a[i];}dbl_vect::dbl_vect(const dbl_vect& v) : size(v.size){   p = new double[size];   assert(p != 0);   for (int i = 0; i < size; ++i)      p[i] = v.p[i];}void dbl_vect::print() const{   for (int i = 0; i < size; ++i)      cout << p[i] << "    ";   cout << endl;}double& dbl_vect::operator[](int i){   assert(i >= 0 && i < size);   return p[i];}dbl_vect& dbl_vect::operator=(const dbl_vect& v){   if (this != &v) {           //do nothing if assigned to self      assert(v.size == size);      for (int i = 0; i < size; ++i)         p[i] = v.p[i];   }   return *this;}dbl_vect dbl_vect::operator+(const dbl_vect& v){   assert(size == v.size);   dbl_vect sum(size);   for (int i = 0; i < size; ++i)      sum.p[i] = p[i] + v.p[i];   return sum;}dbl_vect::dbl_vect(int n): size(n){   if (n < 1) //1)              //precondition assertion      throw (n);   p = new double[n];   if (p == 0)                  //postcondition assertion      throw ("FREE STORE EXHAUSTED");}void g(int n){   try {      dbl_vect  a(n), b(n);   } catch(int m)  {     cerr << "SIZE ERROR " << m << endl;     g(10);      //retry g with legal size  }  catch(const char* error)  {     cerr << error << endl;     abort();  }}int main(){   int n = -5;   // to produce error   g(n);   int look; cin >> look;}