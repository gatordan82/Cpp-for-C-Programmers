/**********************************************************************  Filename:  ch_stac2.h  Chapter:   5      Constructors and Destructors  Compiler:  Borland C++     Version 5.01      Summer 1998  C++ for C Programmers, Edition 3     By Ira Pohl********************************************************************/#include <assert>//using namespace std;class ch_stack {public://the public interface for the ch_stack   explicit ch_stack();   ch_stack(int size, const char str[]);   ch_stack(const ch_stack& str);   explicit ch_stack(int size): max_len( size), top(EMPTY)     { assert(size > 0); s = new char[size]; assert(s != 0); }     ~ch_stack() { delete []s; }            //destructor   void  reset() { top = EMPTY; }   void  push(char c) { s[++top]= c; }   void  print() const;   char  pop() { return s[top--]; }   char  top_of() const { return s[top]; }   bool  empty() const { return (top == EMPTY); }   bool  full() const { return (top == max_len - 1); }private:   enum  { EMPTY = -1 };   char*  s;                   //changed from s[max_len]   int    max_len;   int    top;};//default constructor for ch_stackch_stack::ch_stack():max_len(100),top(EMPTY){   s = new char[100];   assert(s != 0);}//Copy constructor for ch_stack of charactersch_stack::ch_stack(const ch_stack& str):   max_len(str.max_len), top(str.top){   s = new char[str.max_len];   assert(s != 0);   memcpy(s, str.s, max_len);}//copy a char* string into the ch_stackch_stack::ch_stack(int size, const char str[]):   max_len(size){   int i;   assert(size > 0);   s = new char[size];   assert(s != 0);   for (i = 0; i < max_len && str[i] != 0; ++i)      s[i] = str[i];   top = --i;}void ch_stack::print() const{   for (int i = 0; i < max_len && s[i] != 0; ++i)      cout << s[i];   cout << endl;}