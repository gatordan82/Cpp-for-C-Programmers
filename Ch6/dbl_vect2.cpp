/**********************************************************************  Filename:  dbl_ve~1.cpp  Chapter:   6      Operator Overloading and Conversions  Compiler:  Borland C++     Version 5.01      Summer 1998  C++ for C Programmers, Edition 3     By Ira Pohl********************************************************************/#include <iostream>#include <assert>//using namespace std;//A safe array type dbl_vect with [] overloadedconst int DSIZE = 6;class dbl_vect {public:   //constructors and destructor   explicit dbl_vect(int n = 10);   dbl_vect(const dbl_vect& v);   dbl_vect(const double a[], int n);      //initialize by array   ~dbl_vect() { delete []p; }   //other member functions   int  ub()const { return (size-1); }     //upper bound   void print() const;   double&  operator[](int i) ;            //range checked   dbl_vect& operator=(const dbl_vect& v); //assignment   dbl_vect operator+(const dbl_vect& v);private:   double*  p;                             //base pointer   int  size;                              //number of elements};dbl_vect::dbl_vect(int n) : size(n){   assert(n > 0);   p = new double[size];   assert(p != 0);}dbl_vect::dbl_vect(const double a[], int n) : size(n){   assert(n > 0);   p = new double[size];   assert(p != 0);   for (int i = 0; i < size; ++i)      p[i] = a[i];}dbl_vect::dbl_vect(const dbl_vect& v) : size(v.size){   p = new double[size];   assert(p != 0);   for (int i = 0; i < size; ++i)      p[i] = v.p[i];}void dbl_vect::print() const{   for (int i = 0; i < size; ++i)      cout << p[i] << "    ";   cout << endl;}double& dbl_vect::operator[](int i){   assert(i >= 0 && i < size);   return p[i];}dbl_vect& dbl_vect::operator=(const dbl_vect& v){   if (this != &v) {           //do nothing if assigned to self      assert(v.size == size);      for (int i = 0; i < size; ++i)         p[i] = v.p[i];   }   return *this;}dbl_vect dbl_vect::operator+(const dbl_vect& v){   assert(size == v.size);   dbl_vect sum(size);   for (int i = 0; i < size; ++i)      sum.p[i] = p[i] + v.p[i];   return sum;}int main(){   double   data[6] = {1, 2, 3, 4, 5, 6};   dbl_vect a(data, 6), b(data,6);   dbl_vect c(a);   dbl_vect d(data, 6);   cout << "Set : " << endl;   a.print();   b.print();   c.print();   d.print();   a = b;                         //a, b are type dbl_vect   a = b = c;                     //a, b, c are type dbl_vect   cout << "Set a, b, c same " << endl;   a.print();   b.print();   c.print();   a = b + a;                     //assignment and addition   cout << "Set a = b + a: " << endl;   a.print();   a = b + (c = a) + d;           //complicated expression   cout << "Set a = b + (c = a) + d: " << endl;   a.print();   a = dbl_vect(data, DSIZE);     //convert array data[DSIZE]   cout << "Set a = data to DSIZE: " << endl;   a.print();   int look; cin >> look;}