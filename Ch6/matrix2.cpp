/**********************************************************************  Filename:  matrix2.cpp  Chapter:   6      Operator Overloading and Conversions  Compiler:  Borland C++     Version 5.01      Summer 1998  C++ for C Programmers, Edition 3     By Ira Pohl********************************************************************/#include <iostream>#include <assert>//using namespace std;class matrix;      //forward referenceclass dbl_vect {public:   explicit dbl_vect(int n = 10);   ~dbl_vect() { delete []p; }   double& element(int i);                  //access p[i]   double dot_prod(const dbl_vect& v) const;   int  ub() const { return (size - 1); }   //upper bound   void print() const;   friend dbl_vect  mpy(const dbl_vect& v, const matrix& m);private:   double*  p;   int      size;};dbl_vect::dbl_vect(int n) : size(n){   assert(n > 0);   p = new double[size];   assert(p != 0);}double& dbl_vect::element(int i){   assert (i >= 0 && i < size);   return p[i];}void dbl_vect::print()const{   cout << " vector of size " << size << endl;   for (int i = 0; i <size; ++i)      cout << p[i] << "\t";}double dbl_vect::dot_prod(const dbl_vect& v) const{   assert(size == v.size);   double sum = 0.0;   for (int i = 0; i < size; ++i)      sum += p[i] * v.p[i];   return sum;}class matrix {public:   matrix(int d1, int d2);   ~matrix();   int  ub1() const { return(s1 - 1); }   int  ub2() const { return(s2 - 1); }   double&  element(int i, int j);   void print() const;   friend dbl_vect  mpy(const dbl_vect& v, const matrix& m);private:   double**  p;   int    s1, s2;};matrix::matrix(int d1, int d2) : s1(d1), s2(d2){   assert(d1 > 0 && d2 > 0);   p = new double*[s1];   assert(p != 0);   for (int i = 0; i < s1; ++i){      p[i] = new double[s2];      assert(p[i] != 0);   }}matrix::~matrix(){   for (int i = 0; i <= ub1(); ++i)      delete []p[i];   delete []p;}double& matrix::element(int i, int j){  assert(i >= 0 && i <= ub1() && j >= 0 && j <= ub2());  return p[i][j];}void matrix::print() const{  int i, j;  for (i = 0; i < s1; ++i) {      cout << endl;      for (j = 0; j < s2; ++j)         cout << p[i][j] << "    ";  }  cout << endl;}//use privileged access to p in both classesdbl_vect mpy(const dbl_vect& v, const matrix& m){   assert(v.size == m.s1);             //check sizes   dbl_vect  ans(m.s2);   int   i, j;   for (i = 0; i <= m.ub2(); ++i) {      ans.p[i] = 0;      for (j = 0; j <= m.ub1(); ++j) {         cout << v.p[j] << "   " << m.p[j][i] << "  ";         ans.p[i] += v.p[j] * m.p[j][i];      }      cout << "   total: " << ans.p[i] << endl;   }   return ans;}int main(){   matrix m(5, 5);   dbl_vect d(5), dans(5);   int i, j;   for (i = 0; i <= d.ub(); ++i)      d.element(i) = i + 1;   cout << "\ndouble vect d: " << endl;   d.print();   for (i = 0; i <= m.ub1(); ++i)      for (j = 0; j <= m.ub2(); ++j)         m.element(i, j) = (i * 10) + j;   cout << "\nmatrix m: " << endl;   m.print();   dans = mpy(d, m);   cout << "\ndouble vect ans: " << endl;   dans.print();   int look; cin >> look;}