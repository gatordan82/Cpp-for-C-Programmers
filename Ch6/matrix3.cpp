/**********************************************************************  Filename:  matrix3.cpp  Chapter:   6      Operator Overloading and Conversions  Compiler:  Borland C++     Version 5.01      Summer 1998  C++ for C Programmers, Edition 3     By Ira Pohl********************************************************************/#include <iostream>#include <assert>//using namespace std;//dynamic matrix typeclass matrix {public:   matrix(int c, int r);   matrix:: matrix(const matrix& m);   ~matrix();   int ub1() const { return(c_size - 1); }   int ub2() const { return(r_size - 1); }   double& operator()(int i, int j);   friend ostream& operator<<(ostream& out, matrix x);   matrix& operator=(const matrix& m);   matrix& operator+=(matrix& m);private:   int c_size, r_size;   double  **p;};matrix:: matrix(int c, int r):c_size(c), r_size(r){   p = new double*[c];   assert(p != 0);   for (int i = 0; i < c; ++i){      p[i] = new double[r];      assert(p[i] != 0);   }}matrix:: ~matrix(){   for (int i = 0; i < c_size; ++i)      delete [] p[i];   delete [] p;}inline double& matrix::operator()(int i, int j){   assert( i >= 0 && i < c_size &&           j >= 0 && j < r_size);   return p[i][j];}matrix:: matrix(const matrix& m) :c_size(m.c_size), r_size(m.r_size){   p = new double*[c_size];   assert(p != 0);   for (int i = 0; i < c_size; ++i){      p[i] = new double[r_size];      assert(p[i] != 0);   }   for (int i = 0; i < c_size; ++i)      for (int j = 0; j < r_size; ++j)         p[i][j] = m.p[i][j];}matrix& matrix::operator=(const matrix& m){   assert(m.c_size == c_size && m.r_size == r_size);   int i, j;   for (i = 0; i < c_size; ++i)      for (j = 0; j < r_size; ++j)         p[i][j] = m.p[i][j];   return *this;}matrix& matrix::operator+=(matrix& m){   assert(m.c_size == c_size && m.r_size == r_size);   int i, j;   for (i = 0; i < c_size; ++i)      for (j = 0; j < r_size; ++j)         p[i][j] += m.p[i][j];   return *this;}ostream& operator<<(ostream& out, matrix x){   int i, j;   for (i = 0; i < x.c_size; ++i) {      out << endl;      for (j = 0; j < x.r_size;  ++j)         out << x.p[i][j] << "   ";   }  out << endl;  return out;}int main(){   matrix a(3, 3), b(3, 3), c(3, 3);   int i, j;   for (i = 0; i <= a.ub1(); ++i)      for (j = 0; j <= a.ub2(); ++j)         a(i, j) = i + j + 1;   cout << "a matrix: " << a;   for (i = 0; i <= b.ub1(); ++i)      for (j = 0; j <= b.ub2(); ++j)         b(i, j) = i * 10 + j * 10 + 1;   cout << "b matrix: " << b;   c = b;   cout << "c matrix: " << c;   c += b;   cout << "c += b:   " << c;   int look; cin >> look;}